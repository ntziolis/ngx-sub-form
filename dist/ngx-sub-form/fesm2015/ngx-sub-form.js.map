{"version":3,"file":"ngx-sub-form.js","sources":["ng://ngx-sub-form/lib/ngx-sub-form-tokens.ts","ng://ngx-sub-form/lib/ngx-sub-form-utils.ts","ng://ngx-sub-form/lib/ngx-sub-form.component.ts","ng://ngx-sub-form/lib/ngx-root-form.component.ts","ng://ngx-sub-form/lib/ngx-automatic-root-form.component.ts","ng://ngx-sub-form/lib/ngx-sub-form.decorators.ts","ng://ngx-sub-form/public_api.ts","ng://ngx-sub-form/ngx-sub-form.ts"],"sourcesContent":["import { InjectionToken } from '@angular/core';\r\nimport { NgxSubFormComponent } from './ngx-sub-form.component';\r\n\r\n// ----------------------------------------------------------------------------------------\r\n// no need to expose that token out of the lib, do not export that file from public_api.ts!\r\n// ----------------------------------------------------------------------------------------\r\n\r\n// see https://github.com/angular/angular/issues/8277#issuecomment-263029485\r\n// this basically allows us to access the host component\r\n// from a directive without knowing the type of the component at run time\r\nexport const SUB_FORM_COMPONENT_TOKEN = new InjectionToken<NgxSubFormComponent<any>>('NgxSubFormComponentToken');\r\n","import {\r\n  ControlValueAccessor,\r\n  NG_VALUE_ACCESSOR,\r\n  NG_VALIDATORS,\r\n  ValidationErrors,\r\n  FormControl,\r\n  FormArray,\r\n  AbstractControl,\r\n  FormGroup,\r\n} from '@angular/forms';\r\nimport { InjectionToken, Type, forwardRef, OnDestroy } from '@angular/core';\r\nimport { Observable, Subject, timer } from 'rxjs';\r\nimport { takeUntil, debounce } from 'rxjs/operators';\r\nimport { SUB_FORM_COMPONENT_TOKEN } from './ngx-sub-form-tokens';\r\nimport { NgxSubFormComponent } from './ngx-sub-form.component';\r\n\r\nexport type Controls<T> = { [K in keyof T]-?: AbstractControl };\r\n\r\nexport type ControlsNames<T> = { [K in keyof T]-?: K };\r\n\r\nexport type ControlMap<T, V> = { [K in keyof T]-?: V };\r\n\r\nexport type ControlsType<T> = {\r\n  [K in keyof T]-?: T[K] extends any[] ? TypedFormArray<T[K]> : TypedFormControl<T[K]> | TypedFormGroup<T[K]>;\r\n};\r\n\r\nexport type FormErrorsType<T> = {\r\n  [K in keyof T]-?: T[K] extends any[] ? (null | ValidationErrors)[] : ValidationErrors;\r\n};\r\n\r\nexport type FormUpdate<FormInterface> = { [FormControlInterface in keyof FormInterface]?: true };\r\n\r\nexport type FormErrors<FormInterface> = null | Partial<\r\n  FormErrorsType<FormInterface> & {\r\n    formGroup?: ValidationErrors;\r\n  }\r\n>;\r\n\r\n// using set/patch value options signature from form controls to allow typing without additional casting\r\nexport interface TypedAbstractControl<TValue> extends AbstractControl {\r\n  value: TValue;\r\n  valueChanges: Observable<TValue>;\r\n  setValue(value: TValue, options?: Parameters<AbstractControl['setValue']>[1]): void;\r\n  patchValue(value: Partial<TValue>, options?: Parameters<AbstractControl['patchValue']>[1]): void;\r\n}\r\n\r\nexport interface TypedFormGroup<TValue> extends FormGroup {\r\n  value: TValue;\r\n  valueChanges: Observable<TValue>;\r\n  controls: ControlsType<TValue>;\r\n  setValue(value: TValue, options?: Parameters<FormGroup['setValue']>[1]): void;\r\n  patchValue(value: Partial<TValue>, options?: Parameters<FormGroup['patchValue']>[1]): void;\r\n  getRawValue(): TValue;\r\n}\r\n\r\nexport interface TypedFormArray<TValue extends any[]> extends FormArray {\r\n  value: TValue;\r\n  valueChanges: Observable<TValue>;\r\n  controls: TypedAbstractControl<TValue>[];\r\n  setValue(value: TValue, options?: Parameters<FormArray['setValue']>[1]): void;\r\n  patchValue(value: TValue, options?: Parameters<FormArray['patchValue']>[1]): void;\r\n  getRawValue(): TValue;\r\n}\r\n\r\nexport interface TypedFormControl<TValue> extends FormGroup {\r\n  value: TValue;\r\n  valueChanges: Observable<TValue>;\r\n  setValue(value: TValue, options?: Parameters<FormControl['setValue']>[1]): void;\r\n  patchValue(value: Partial<TValue>, options?: Parameters<FormControl['patchValue']>[1]): void;\r\n}\r\n\r\nexport type KeysWithType<T, V> = { [K in keyof T]: T[K] extends V ? K : never }[keyof T];\r\n\r\nexport type ArrayPropertyKey<T> = KeysWithType<T, Array<any>>;\r\n\r\nexport type ArrayPropertyValue<T, K extends ArrayPropertyKey<T> = ArrayPropertyKey<T>> = T[K] extends Array<infer U>\r\n  ? U\r\n  : never;\r\n\r\nexport function subformComponentProviders(\r\n  component: any,\r\n): {\r\n  provide: InjectionToken<ControlValueAccessor>;\r\n  useExisting: Type<any>;\r\n  multi?: boolean;\r\n}[] {\r\n  return [\r\n    {\r\n      provide: NG_VALUE_ACCESSOR,\r\n      useExisting: forwardRef(() => component),\r\n      multi: true,\r\n    },\r\n    {\r\n      provide: NG_VALIDATORS,\r\n      useExisting: forwardRef(() => component),\r\n      multi: true,\r\n    },\r\n    {\r\n      provide: SUB_FORM_COMPONENT_TOKEN,\r\n      useExisting: forwardRef(() => component),\r\n    },\r\n  ];\r\n}\r\n\r\nconst wrapAsQuote = (str: string): string => `\"${str}\"`;\r\n\r\nexport class MissingFormControlsError<T extends string> extends Error {\r\n  constructor(missingFormControls: T[]) {\r\n    super(\r\n      `Attempt to update the form value with an object that doesn't contains some of the required form control keys.\\nMissing: ${missingFormControls\r\n        .map(wrapAsQuote)\r\n        .join(`, `)}`,\r\n    );\r\n  }\r\n}\r\n\r\nexport const NGX_SUB_FORM_HANDLE_VALUE_CHANGES_RATE_STRATEGIES = {\r\n  debounce: <T, U>(time: number): ReturnType<NgxSubFormComponent<T, U>['handleEmissionRate']> => obs =>\r\n    obs.pipe(debounce(() => timer(time))),\r\n};\r\n\r\n/**\r\n * Easily unsubscribe from an observable stream by appending `takeUntilDestroyed(this)` to the observable pipe.\r\n * If the component already has a `ngOnDestroy` method defined, it will call this first.\r\n * Note that the component *must* implement OnDestroy for this to work (the typings will enforce this anyway)\r\n */\r\nexport function takeUntilDestroyed<T>(component: OnDestroy): (source: Observable<T>) => Observable<T> {\r\n  return (source: Observable<T>): Observable<T> => {\r\n    const onDestroy = new Subject();\r\n    const previousOnDestroy = component.ngOnDestroy;\r\n\r\n    component.ngOnDestroy = () => {\r\n      if (previousOnDestroy) {\r\n        previousOnDestroy.apply(component);\r\n      }\r\n\r\n      onDestroy.next();\r\n      onDestroy.complete();\r\n    };\r\n\r\n    return source.pipe(takeUntil(onDestroy));\r\n  };\r\n}\r\n\r\n/** @internal */\r\nexport function isNullOrUndefined(obj: any): obj is null | undefined {\r\n  return obj === null || obj === undefined;\r\n}\r\n","import { OnDestroy, Directive, Component } from '@angular/core';\r\nimport {\r\n  AbstractControl,\r\n  AbstractControlOptions,\r\n  ControlValueAccessor,\r\n  FormGroup,\r\n  ValidationErrors,\r\n  Validator,\r\n  FormArray,\r\n  FormControl,\r\n} from '@angular/forms';\r\nimport { merge, Observable, Subscription } from 'rxjs';\r\nimport { delay, filter, map, startWith, withLatestFrom } from 'rxjs/operators';\r\nimport {\r\n  ControlMap,\r\n  Controls,\r\n  ControlsNames,\r\n  FormUpdate,\r\n  MissingFormControlsError,\r\n  FormErrors,\r\n  isNullOrUndefined,\r\n  ControlsType,\r\n  ArrayPropertyKey,\r\n  TypedAbstractControl,\r\n  TypedFormGroup,\r\n} from './ngx-sub-form-utils';\r\nimport { FormGroupOptions, NgxFormWithArrayControls, OnFormUpdate } from './ngx-sub-form.types';\r\n\r\ntype MapControlFunction<FormInterface, MapValue> = (\r\n  ctrl: TypedAbstractControl<any>,\r\n  key: keyof FormInterface,\r\n) => MapValue;\r\ntype FilterControlFunction<FormInterface> = (\r\n  ctrl: TypedAbstractControl<any>,\r\n  key: keyof FormInterface,\r\n  isCtrlWithinFormArray: boolean,\r\n) => boolean;\r\n\r\n@Directive()\r\n// tslint:disable-next-line: directive-class-suffix\r\nexport abstract class NgxSubFormComponent<ControlInterface, FormInterface = ControlInterface>\r\n  implements ControlValueAccessor, Validator, OnDestroy, OnFormUpdate<FormInterface> {\r\n  public get formGroupControls(): ControlsType<FormInterface> {\r\n    // @note form-group-undefined we need the return null here because we do not want to expose the fact that\r\n    // the form can be undefined, it's handled internally to contain an Angular bug\r\n    if (!this.formGroup) {\r\n      return null as any;\r\n    }\r\n\r\n    return (this.formGroup.controls as unknown) as ControlsType<FormInterface>;\r\n  }\r\n\r\n  public get formGroupValues(): Required<FormInterface> {\r\n    // see @note form-group-undefined for non-null assertion reason\r\n    // tslint:disable-next-line:no-non-null-assertion\r\n    return this.mapControls(ctrl => ctrl.value)!;\r\n  }\r\n\r\n  public get formGroupErrors(): FormErrors<FormInterface> {\r\n    const errors: FormErrors<FormInterface> = this.mapControls<ValidationErrors | ValidationErrors[] | null>(\r\n      ctrl => ctrl.errors,\r\n      (ctrl, _, isCtrlWithinFormArray) => (isCtrlWithinFormArray ? true : ctrl.invalid),\r\n      true,\r\n    ) as FormErrors<FormInterface>;\r\n\r\n    if (!this.formGroup.errors && (!errors || !Object.keys(errors).length)) {\r\n      return null;\r\n    }\r\n\r\n    return Object.assign({}, this.formGroup.errors ? { formGroup: this.formGroup.errors } : {}, errors);\r\n  }\r\n\r\n  public get formControlNames(): ControlsNames<FormInterface> {\r\n    // see @note form-group-undefined for as syntax\r\n    return this.mapControls(\r\n      (_, key) => key,\r\n      () => true,\r\n      false,\r\n    ) as ControlsNames<FormInterface>;\r\n  }\r\n\r\n  private controlKeys: (keyof FormInterface)[] = [];\r\n\r\n  // when developing the lib it's a good idea to set the formGroup type\r\n  // to current + `| undefined` to catch a bunch of possible issues\r\n  // see @note form-group-undefined\r\n  public formGroup: TypedFormGroup<FormInterface> = (new FormGroup(\r\n    this._getFormControls(),\r\n    this.getFormGroupControlOptions() as AbstractControlOptions,\r\n  ) as unknown) as TypedFormGroup<FormInterface>;\r\n\r\n  protected onChange: Function | undefined = undefined;\r\n  protected onTouched: Function | undefined = undefined;\r\n  protected emitNullOnDestroy = true;\r\n  protected emitInitialValueOnInit = true;\r\n\r\n  private subscription: Subscription | undefined = undefined;\r\n\r\n  // a RootFormComponent with the disabled property set initially to `false`\r\n  // will call `setDisabledState` *before* the form is actually available\r\n  // and it wouldn't be disabled once available, therefore we use this flag\r\n  // to check when the FormGroup is created if we should disable it\r\n  private controlDisabled = false;\r\n\r\n  constructor() {\r\n    // if the form has default values, they should be applied straight away\r\n    const defaultValues: Partial<FormInterface> | null = this.getDefaultValues();\r\n    if (!!defaultValues) {\r\n      this.formGroup.reset(defaultValues, { emitEvent: false });\r\n    }\r\n\r\n    // `setTimeout` and `updateValueAndValidity` are both required here\r\n    // indeed, if you check the demo you'll notice that without it, if\r\n    // you select `Droid` and `Assassin` for example the displayed errors\r\n    // are not yet defined for the field `assassinDroid`\r\n    // (until you change one of the value in that form)\r\n    setTimeout(() => {\r\n      if (this.formGroup) {\r\n        this.formGroup.updateValueAndValidity({ emitEvent: false });\r\n\r\n        if (this.controlDisabled) {\r\n          this.formGroup.disable();\r\n        }\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  // can't define them directly\r\n  protected abstract getFormControls(): Controls<FormInterface>;\r\n  private _getFormControls(): Controls<FormInterface> {\r\n    const controls: Controls<FormInterface> = this.getFormControls();\r\n\r\n    this.controlKeys = (Object.keys(controls) as unknown) as (keyof FormInterface)[];\r\n\r\n    return controls;\r\n  }\r\n\r\n  private mapControls<MapValue>(\r\n    mapControl: MapControlFunction<FormInterface, MapValue>,\r\n    filterControl: FilterControlFunction<FormInterface>,\r\n    recursiveIfArray: boolean,\r\n  ): Partial<ControlMap<FormInterface, MapValue | MapValue[]>> | null;\r\n  private mapControls<MapValue>(\r\n    mapControl: MapControlFunction<FormInterface, MapValue>,\r\n  ): ControlMap<FormInterface, MapValue | MapValue[]> | null;\r\n  private mapControls<MapValue>(\r\n    mapControl: MapControlFunction<FormInterface, MapValue>,\r\n    filterControl: FilterControlFunction<FormInterface> = () => true,\r\n    recursiveIfArray: boolean = true,\r\n  ): Partial<ControlMap<FormInterface, MapValue | MapValue[]>> | null {\r\n    if (!this.formGroup) {\r\n      return null;\r\n    }\r\n\r\n    const formControls: ControlsType<FormInterface> = this.formGroup.controls;\r\n\r\n    const controls: Partial<ControlMap<FormInterface, MapValue | MapValue[]>> = {};\r\n\r\n    for (const key in formControls) {\r\n      if (this.formGroup.controls.hasOwnProperty(key)) {\r\n        const control = formControls[key];\r\n\r\n        if (recursiveIfArray && control instanceof FormArray) {\r\n          const values: MapValue[] = [];\r\n\r\n          for (let i = 0; i < control.length; i++) {\r\n            if (filterControl(control.at(i), key, true)) {\r\n              values.push(mapControl(control.at(i), key));\r\n            }\r\n          }\r\n\r\n          if (values.length > 0 && values.some(x => !isNullOrUndefined(x))) {\r\n            controls[key] = values;\r\n          }\r\n        } else if (control && filterControl(control, key, false)) {\r\n          controls[key] = mapControl(control, key);\r\n        }\r\n      }\r\n    }\r\n\r\n    return controls;\r\n  }\r\n\r\n  public onFormUpdate(formUpdate: FormUpdate<FormInterface>): void {}\r\n\r\n  /**\r\n   * Extend this method to provide custom local FormGroup level validation\r\n   */\r\n  protected getFormGroupControlOptions(): FormGroupOptions<FormInterface> {\r\n    return {};\r\n  }\r\n\r\n  public validate(): ValidationErrors | null {\r\n    if (\r\n      // @hack see where defining this.formGroup to undefined\r\n      !this.formGroup ||\r\n      this.formGroup.valid\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    return this.formGroupErrors;\r\n  }\r\n\r\n  // @todo could this be removed to avoid an override and just use `takeUntilDestroyed`?\r\n  public ngOnDestroy(): void {\r\n    // @hack there's a memory leak within Angular and those components\r\n    // are not correctly cleaned up which leads to error if a form is defined\r\n    // with validators and then it's been removed, the validator would still fail\r\n    // `as any` if because we do not want to define the formGroup as FormGroup | undefined\r\n    // everything related to undefined is handled internally and shouldn't be exposed to end user\r\n    (this.formGroup as any) = undefined;\r\n\r\n    if (this.subscription) {\r\n      this.subscription.unsubscribe();\r\n    }\r\n\r\n    if (this.emitNullOnDestroy && this.onChange) {\r\n      this.onChange(null);\r\n    }\r\n\r\n    this.onChange = undefined;\r\n  }\r\n\r\n  // when getDefaultValues is defined, you do not need to specify the default values\r\n  // in your form (the ones defined within the `getFormControls` method)\r\n  protected getDefaultValues(): Partial<FormInterface> | null {\r\n    return null;\r\n  }\r\n\r\n  public writeValue(obj: Required<ControlInterface> | null): void {\r\n    // @hack see where defining this.formGroup to undefined\r\n    if (!this.formGroup) {\r\n      return;\r\n    }\r\n\r\n    const defaultValues: Partial<FormInterface> | null = this.getDefaultValues();\r\n\r\n    const transformedValue: FormInterface | null = this.transformToFormGroup(\r\n      obj === undefined ? null : obj,\r\n      defaultValues,\r\n    );\r\n\r\n    if (isNullOrUndefined(transformedValue)) {\r\n      this.formGroup.reset(\r\n        // calling `reset` on a form with `null` throws an error but if nothing is passed\r\n        // (undefined) it will reset all the form values to null (as expected)\r\n        defaultValues === null ? undefined : defaultValues,\r\n        // emit to keep internal and external information about data in of control in sync, when\r\n        // null/undefined was passed into writeValue\r\n        // while internally being replaced with defaultValues\r\n        { emitEvent: isNullOrUndefined(obj) && !isNullOrUndefined(defaultValues) },\r\n      );\r\n    } else {\r\n      const missingKeys: (keyof FormInterface)[] = this.getMissingKeys(transformedValue);\r\n      if (missingKeys.length > 0) {\r\n        throw new MissingFormControlsError(missingKeys as string[]);\r\n      }\r\n\r\n      this.handleFormArrayControls(transformedValue);\r\n\r\n      // The next few lines are weird but it's as workaround.\r\n      // There are some shady behavior with the disabled state\r\n      // of a form. Apparently, using `setValue` on a disabled\r\n      // form does re-enable it *sometimes*, not always.\r\n      // related issues:\r\n      // https://github.com/angular/angular/issues/31506\r\n      // https://github.com/angular/angular/issues/22556\r\n      // but if you display `this.formGroup.disabled`\r\n      // before and after the `setValue` is called, it's the same\r\n      // result which is even weirder\r\n      const fgDisabled: boolean = this.formGroup.disabled;\r\n\r\n      this.formGroup.setValue(transformedValue, {\r\n        // emit to keep internal and external information about data in of control in sync, when\r\n        // null/undefined was passed into writeValue\r\n        // while internally being replaced with transformedValue\r\n        emitEvent: isNullOrUndefined(obj),\r\n      });\r\n\r\n      if (fgDisabled) {\r\n        this.formGroup.disable();\r\n      }\r\n    }\r\n\r\n    this.formGroup.markAsPristine();\r\n    this.formGroup.markAsUntouched();\r\n  }\r\n\r\n  private handleFormArrayControls(obj: any) {\r\n    Object.entries(obj).forEach(([key, value]) => {\r\n      if (this.formGroup.get(key) instanceof FormArray && Array.isArray(value)) {\r\n        const formArray: FormArray = this.formGroup.get(key) as FormArray;\r\n\r\n        // instead of creating a new array every time and push a new FormControl\r\n        // we just remove or add what is necessary so that:\r\n        // - it is as efficient as possible and do not create unnecessary FormControl every time\r\n        // - validators are not destroyed/created again and eventually fire again for no reason\r\n        while (formArray.length > value.length) {\r\n          formArray.removeAt(formArray.length - 1);\r\n        }\r\n\r\n        for (let i = formArray.length; i < value.length; i++) {\r\n          if (this.formIsFormWithArrayControls()) {\r\n            formArray.insert(i, this.createFormArrayControl(key as ArrayPropertyKey<FormInterface>, value[i]));\r\n          } else {\r\n            formArray.insert(i, new FormControl(value[i]));\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private formIsFormWithArrayControls(): this is NgxFormWithArrayControls<FormInterface> {\r\n    return typeof ((this as unknown) as NgxFormWithArrayControls<FormInterface>).createFormArrayControl === 'function';\r\n  }\r\n\r\n  private getMissingKeys(transformedValue: FormInterface | null) {\r\n    // `controlKeys` can be an empty array, empty forms are allowed\r\n    const missingKeys: (keyof FormInterface)[] = this.controlKeys.reduce((keys, key) => {\r\n      if (isNullOrUndefined(transformedValue) || transformedValue[key] === undefined) {\r\n        keys.push(key);\r\n      }\r\n\r\n      return keys;\r\n    }, [] as (keyof FormInterface)[]);\r\n\r\n    return missingKeys;\r\n  }\r\n\r\n  // when customizing the emission rate of your sub form component, remember not to **mutate** the stream\r\n  // it is safe to throttle, debounce, delay, etc but using skip, first, last or mutating data inside\r\n  // the stream will cause issues!\r\n  protected handleEmissionRate(): (obs$: Observable<FormInterface>) => Observable<FormInterface> {\r\n    return obs$ => obs$;\r\n  }\r\n\r\n  // that method can be overridden if the\r\n  // shape of the form needs to be modified\r\n  protected transformToFormGroup(\r\n    obj: ControlInterface | null,\r\n    defaultValues: Partial<FormInterface> | null,\r\n  ): FormInterface | null {\r\n    return (obj as any) as FormInterface;\r\n  }\r\n\r\n  // that method can be overridden if the\r\n  // shape of the form needs to be modified\r\n  protected transformFromFormGroup(formValue: FormInterface): ControlInterface | null {\r\n    return (formValue as any) as ControlInterface;\r\n  }\r\n\r\n  public registerOnChange(fn: (_: any) => void): void {\r\n    if (!this.formGroup) {\r\n      return;\r\n    }\r\n\r\n    this.onChange = fn;\r\n\r\n    interface KeyValueForm {\r\n      key: keyof FormInterface;\r\n      value: unknown;\r\n    }\r\n\r\n    const formControlNames: (keyof FormInterface)[] = Object.keys(this.formControlNames) as (keyof FormInterface)[];\r\n\r\n    const formValues: Observable<KeyValueForm>[] = formControlNames.map(key =>\r\n      ((this.formGroup.controls[key] as unknown) as AbstractControl).valueChanges.pipe(\r\n        startWith(this.formGroup.controls[key].value),\r\n        map(value => ({ key, value })),\r\n      ),\r\n    );\r\n\r\n    const lastKeyEmitted$: Observable<keyof FormInterface> = merge(...formValues.map(obs => obs.pipe(map(x => x.key))));\r\n\r\n    this.subscription = this.formGroup.valueChanges\r\n      .pipe(\r\n        // hook to give access to the observable for sub-classes\r\n        // this allow sub-classes (for example) to debounce, throttle, etc\r\n        this.handleEmissionRate(),\r\n        startWith(this.formGroup.value),\r\n        // this is required otherwise an `ExpressionChangedAfterItHasBeenCheckedError` will happen\r\n        // this is due to the fact that parent component will define a given state for the form that might\r\n        // be changed once the children are being initialized\r\n        delay(0),\r\n        filter(() => !!this.formGroup),\r\n        // detect which stream emitted last\r\n        withLatestFrom(lastKeyEmitted$),\r\n        map(([_, keyLastEmit], index) => {\r\n          if (index > 0 && this.onTouched) {\r\n            this.onTouched();\r\n          }\r\n\r\n          if (index > 0 || (index === 0 && this.emitInitialValueOnInit)) {\r\n            if (this.onChange) {\r\n              this.onChange(\r\n                this.transformFromFormGroup(\r\n                  // do not use the changes passed by `this.formGroup.valueChanges` here\r\n                  // as we've got a delay(0) above, on the next tick the form data might\r\n                  // be outdated and might result into an inconsistent state where a form\r\n                  // state is valid (base on latest value) but the previous value\r\n                  // (the one passed by `this.formGroup.valueChanges` would be the previous one)\r\n                  this.formGroup.value,\r\n                ),\r\n              );\r\n            }\r\n\r\n            const formUpdate: FormUpdate<FormInterface> = {};\r\n            formUpdate[keyLastEmit] = true;\r\n            this.onFormUpdate(formUpdate);\r\n          }\r\n        }),\r\n      )\r\n      .subscribe();\r\n  }\r\n\r\n  public registerOnTouched(fn: any): void {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  public setDisabledState(shouldDisable: boolean | undefined): void {\r\n    this.controlDisabled = !!shouldDisable;\r\n\r\n    if (!this.formGroup) {\r\n      return;\r\n    }\r\n\r\n    if (shouldDisable) {\r\n      this.formGroup.disable({ emitEvent: false });\r\n    } else {\r\n      this.formGroup.enable({ emitEvent: false });\r\n    }\r\n  }\r\n}\r\n\r\n@Directive()\r\n// tslint:disable-next-line: directive-class-suffix\r\nexport abstract class NgxSubFormRemapComponent<ControlInterface, FormInterface> extends NgxSubFormComponent<\r\n  ControlInterface,\r\n  FormInterface\r\n> {\r\n  protected abstract transformToFormGroup(\r\n    obj: ControlInterface | null,\r\n    defaultValues: Partial<FormInterface> | null,\r\n  ): FormInterface | null;\r\n  protected abstract transformFromFormGroup(formValue: FormInterface): ControlInterface | null;\r\n}\r\n","import { EventEmitter, OnInit, Input, Component, Directive } from '@angular/core';\r\nimport isEqual from 'fast-deep-equal';\r\nimport { BehaviorSubject, Subject } from 'rxjs';\r\nimport { filter, tap } from 'rxjs/operators';\r\nimport { NgxSubFormRemapComponent } from './ngx-sub-form.component';\r\nimport { takeUntilDestroyed, isNullOrUndefined } from './ngx-sub-form-utils';\r\n\r\n@Directive()\r\n// tslint:disable-next-line: directive-class-suffix\r\nexport abstract class NgxRootFormComponent<ControlInterface, FormInterface = ControlInterface>\r\n  extends NgxSubFormRemapComponent<ControlInterface, FormInterface>\r\n  implements OnInit {\r\n  public abstract dataInput: Required<ControlInterface> | null | undefined;\r\n  // `Input` values are set while the `ngOnChanges` hook is ran\r\n  // and it does happen before the `ngOnInit` where we start\r\n  // listening to `dataInput$`. Therefore, it cannot be a `Subject`\r\n  // or we will miss the first value\r\n  protected dataInput$: BehaviorSubject<Required<ControlInterface> | null | undefined> = new BehaviorSubject<\r\n    Required<ControlInterface> | null | undefined\r\n  >(null);\r\n\r\n  public abstract dataOutput: EventEmitter<ControlInterface>;\r\n  // using a private variable `_dataOutput$` to be able to control the\r\n  // emission rate with a debounce or throttle for ex\r\n  /** @internal */\r\n  protected _dataOutput$: Subject<ControlInterface> = new Subject();\r\n\r\n  @Input()\r\n  public set disabled(shouldDisable: boolean | undefined) {\r\n    this.setDisabledState(shouldDisable);\r\n  }\r\n\r\n  protected emitInitialValueOnInit = false;\r\n  protected emitNullOnDestroy = false;\r\n\r\n  protected dataValue: ControlInterface | null = null;\r\n\r\n  public ngOnInit(): void {\r\n    // we need to manually call registerOnChange because that function\r\n    // handles most of the logic from NgxSubForm and when it's called\r\n    // as a ControlValueAccessor that function is called by Angular itself\r\n    this.registerOnChange(data => this.onRegisterOnChangeHook(data));\r\n\r\n    this.dataInput$\r\n      .pipe(\r\n        filter(newValue => !isEqual(newValue, this.formGroup.value)),\r\n        tap(newValue => {\r\n          if (!isNullOrUndefined(newValue)) {\r\n            this.writeValue(newValue);\r\n          }\r\n        }),\r\n        takeUntilDestroyed(this),\r\n      )\r\n      .subscribe();\r\n\r\n    this._dataOutput$\r\n      .pipe(\r\n        filter(() => this.formGroup.valid),\r\n        tap(value => this.dataOutput.emit(value)),\r\n        takeUntilDestroyed(this),\r\n      )\r\n      .subscribe();\r\n  }\r\n\r\n  /** @internal */\r\n  protected onRegisterOnChangeHook(data: ControlInterface | null): boolean {\r\n    if (this.formGroup.invalid || isEqual(data, this.dataInput$.value)) {\r\n      return false;\r\n    }\r\n\r\n    this.dataValue = data;\r\n    return true;\r\n  }\r\n\r\n  // called by the DataInput decorator\r\n  /** @internal */\r\n  public dataInputUpdated(data: Required<ControlInterface> | null | undefined): void {\r\n    this.dataInput$.next(data);\r\n  }\r\n\r\n  public writeValue(obj: Required<ControlInterface> | null): void {\r\n    this.dataValue = obj;\r\n    super.writeValue(obj);\r\n  }\r\n\r\n  protected transformToFormGroup(\r\n    obj: ControlInterface | null,\r\n    defaultValues: Partial<FormInterface> | null,\r\n  ): FormInterface | null {\r\n    return (obj as unknown) as FormInterface;\r\n  }\r\n\r\n  protected transformFromFormGroup(formValue: FormInterface): ControlInterface | null {\r\n    return (formValue as unknown) as ControlInterface;\r\n  }\r\n\r\n  public manualSave(): void {\r\n    if (!isNullOrUndefined(this.dataValue) && this.formGroup.valid) {\r\n      this._dataOutput$.next(this.dataValue);\r\n    }\r\n  }\r\n}\r\n","import { OnInit, Directive } from '@angular/core';\r\nimport { NgxRootFormComponent } from './ngx-root-form.component';\r\n\r\n@Directive()\r\n// tslint:disable-next-line: directive-class-suffix\r\nexport abstract class NgxAutomaticRootFormComponent<ControlInterface, FormInterface = ControlInterface>\r\n  extends NgxRootFormComponent<ControlInterface, FormInterface>\r\n  implements OnInit {\r\n  /** @internal */\r\n  protected onRegisterOnChangeHook(data: ControlInterface | null) {\r\n    if (!super.onRegisterOnChangeHook(data)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.formGroup) {\r\n      this.formGroup.markAsPristine();\r\n\r\n      if (this.formGroup.valid) {\r\n        this.manualSave();\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n","import { NgxRootFormComponent } from './ngx-root-form.component';\r\n\r\nexport class DataInputUsedOnWrongPropertyError extends Error {\r\n  constructor(calledOnPropertyKey: string) {\r\n    super(\r\n      `You're trying to apply the \"DataInput\" decorator on a property called \"${calledOnPropertyKey}\". That decorator should only be used on a property called \"dataInput\"`,\r\n    );\r\n  }\r\n}\r\n\r\nexport function DataInput() {\r\n  return function<ControlInterface, FormInterface = ControlInterface>(\r\n    target: NgxRootFormComponent<ControlInterface, FormInterface>,\r\n    propertyKey: string,\r\n  ) {\r\n    if (propertyKey !== 'dataInput') {\r\n      throw new DataInputUsedOnWrongPropertyError(propertyKey);\r\n    }\r\n\r\n    Object.defineProperty(target, propertyKey, {\r\n      set: function(dataInputValue) {\r\n        (this as NgxRootFormComponent<ControlInterface, FormInterface>).dataInputUpdated(dataInputValue);\r\n      },\r\n    });\r\n  };\r\n}\r\n","/*\r\n * Public API Surface of sub-form\r\n */\r\n\r\nexport * from './lib/ngx-sub-form-utils';\r\nexport * from './lib/ngx-sub-form.component';\r\nexport * from './lib/ngx-root-form.component';\r\nexport * from './lib/ngx-automatic-root-form.component';\r\nexport * from './lib/ngx-sub-form.types';\r\nexport * from './lib/ngx-sub-form.decorators';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n\nexport {SUB_FORM_COMPONENT_TOKEN as ɵa} from './lib/ngx-sub-form-tokens';"],"names":[],"mappings":"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"}